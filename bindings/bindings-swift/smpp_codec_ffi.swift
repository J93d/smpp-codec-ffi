// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(smpp_codec_ffiFFI)
import smpp_codec_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_smpp_codec_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_smpp_codec_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * Collection of standard SMPP TLV tags.
 */
public protocol TagsProtocol : AnyObject {
    
}

/**
 * Collection of standard SMPP TLV tags.
 */
open class Tags:
    TagsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smpp_codec_ffi_fn_clone_tags(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_smpp_codec_ffi_fn_free_tags(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTags: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Tags

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Tags {
        return Tags(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Tags) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tags {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Tags, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTags_lift(_ pointer: UnsafeMutableRawPointer) throws -> Tags {
    return try FfiConverterTypeTags.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTags_lower(_ value: Tags) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTags.lower(value)
}


/**
 * Represents a Bind request (Receiver, Transmitter, or Transceiver).
 */
public struct BindRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The bind mode (Transmitter, Receiver, or Transceiver).
     */
    public var mode: BindMode
    /**
     * The system_id (username).
     */
    public var systemId: String
    /**
     * The password.
     */
    public var password: String
    /**
     * The system type.
     */
    public var systemType: String
    /**
     * The interface version.
     */
    public var interfaceVersion: UInt8
    /**
     * The Type of Number for the address.
     */
    public var addrTon: Ton
    /**
     * The Numbering Plan Indicator for the address.
     */
    public var addrNpi: Npi
    /**
     * The address range (regex).
     */
    public var addressRange: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The bind mode (Transmitter, Receiver, or Transceiver).
         */mode: BindMode, 
        /**
         * The system_id (username).
         */systemId: String, 
        /**
         * The password.
         */password: String, 
        /**
         * The system type.
         */systemType: String, 
        /**
         * The interface version.
         */interfaceVersion: UInt8, 
        /**
         * The Type of Number for the address.
         */addrTon: Ton, 
        /**
         * The Numbering Plan Indicator for the address.
         */addrNpi: Npi, 
        /**
         * The address range (regex).
         */addressRange: String) {
        self.sequenceNumber = sequenceNumber
        self.mode = mode
        self.systemId = systemId
        self.password = password
        self.systemType = systemType
        self.interfaceVersion = interfaceVersion
        self.addrTon = addrTon
        self.addrNpi = addrNpi
        self.addressRange = addressRange
    }
}



extension BindRequest: Equatable, Hashable {
    public static func ==(lhs: BindRequest, rhs: BindRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.mode != rhs.mode {
            return false
        }
        if lhs.systemId != rhs.systemId {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.systemType != rhs.systemType {
            return false
        }
        if lhs.interfaceVersion != rhs.interfaceVersion {
            return false
        }
        if lhs.addrTon != rhs.addrTon {
            return false
        }
        if lhs.addrNpi != rhs.addrNpi {
            return false
        }
        if lhs.addressRange != rhs.addressRange {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(mode)
        hasher.combine(systemId)
        hasher.combine(password)
        hasher.combine(systemType)
        hasher.combine(interfaceVersion)
        hasher.combine(addrTon)
        hasher.combine(addrNpi)
        hasher.combine(addressRange)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBindRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BindRequest {
        return
            try BindRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                mode: FfiConverterTypeBindMode.read(from: &buf), 
                systemId: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf), 
                systemType: FfiConverterString.read(from: &buf), 
                interfaceVersion: FfiConverterUInt8.read(from: &buf), 
                addrTon: FfiConverterTypeTon.read(from: &buf), 
                addrNpi: FfiConverterTypeNpi.read(from: &buf), 
                addressRange: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BindRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterTypeBindMode.write(value.mode, into: &buf)
        FfiConverterString.write(value.systemId, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
        FfiConverterString.write(value.systemType, into: &buf)
        FfiConverterUInt8.write(value.interfaceVersion, into: &buf)
        FfiConverterTypeTon.write(value.addrTon, into: &buf)
        FfiConverterTypeNpi.write(value.addrNpi, into: &buf)
        FfiConverterString.write(value.addressRange, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBindRequest_lift(_ buf: RustBuffer) throws -> BindRequest {
    return try FfiConverterTypeBindRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBindRequest_lower(_ value: BindRequest) -> RustBuffer {
    return FfiConverterTypeBindRequest.lower(value)
}


/**
 * Represents a Bind response.
 */
public struct BindResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The system_id.
     */
    public var systemId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The system_id.
         */systemId: String) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.systemId = systemId
    }
}



extension BindResponse: Equatable, Hashable {
    public static func ==(lhs: BindResponse, rhs: BindResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.systemId != rhs.systemId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(systemId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBindResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BindResponse {
        return
            try BindResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                systemId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BindResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.systemId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBindResponse_lift(_ buf: RustBuffer) throws -> BindResponse {
    return try FfiConverterTypeBindResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBindResponse_lower(_ value: BindResponse) -> RustBuffer {
    return FfiConverterTypeBindResponse.lower(value)
}


/**
 * Represents a Broadcast SM request.
 */
public struct BroadcastSmRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The service type.
     */
    public var serviceType: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * The priority flag.
     */
    public var priorityFlag: UInt8
    /**
     * The schedule delivery time.
     */
    public var scheduleDeliveryTime: String?
    /**
     * The validity period.
     */
    public var validityPeriod: String?
    /**
     * The replace if present flag.
     */
    public var replaceIfPresentFlag: UInt8
    /**
     * The data coding scheme.
     */
    public var dataCoding: UInt8
    /**
     * The default message ID.
     */
    public var smDefaultMsgId: UInt8
    /**
     * Optional TLV parameters.
     */
    public var optionalParams: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The service type.
         */serviceType: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * The priority flag.
         */priorityFlag: UInt8, 
        /**
         * The schedule delivery time.
         */scheduleDeliveryTime: String?, 
        /**
         * The validity period.
         */validityPeriod: String?, 
        /**
         * The replace if present flag.
         */replaceIfPresentFlag: UInt8, 
        /**
         * The data coding scheme.
         */dataCoding: UInt8, 
        /**
         * The default message ID.
         */smDefaultMsgId: UInt8, 
        /**
         * Optional TLV parameters.
         */optionalParams: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.serviceType = serviceType
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
        self.messageId = messageId
        self.priorityFlag = priorityFlag
        self.scheduleDeliveryTime = scheduleDeliveryTime
        self.validityPeriod = validityPeriod
        self.replaceIfPresentFlag = replaceIfPresentFlag
        self.dataCoding = dataCoding
        self.smDefaultMsgId = smDefaultMsgId
        self.optionalParams = optionalParams
    }
}



extension BroadcastSmRequest: Equatable, Hashable {
    public static func ==(lhs: BroadcastSmRequest, rhs: BroadcastSmRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.serviceType != rhs.serviceType {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.priorityFlag != rhs.priorityFlag {
            return false
        }
        if lhs.scheduleDeliveryTime != rhs.scheduleDeliveryTime {
            return false
        }
        if lhs.validityPeriod != rhs.validityPeriod {
            return false
        }
        if lhs.replaceIfPresentFlag != rhs.replaceIfPresentFlag {
            return false
        }
        if lhs.dataCoding != rhs.dataCoding {
            return false
        }
        if lhs.smDefaultMsgId != rhs.smDefaultMsgId {
            return false
        }
        if lhs.optionalParams != rhs.optionalParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(serviceType)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
        hasher.combine(messageId)
        hasher.combine(priorityFlag)
        hasher.combine(scheduleDeliveryTime)
        hasher.combine(validityPeriod)
        hasher.combine(replaceIfPresentFlag)
        hasher.combine(dataCoding)
        hasher.combine(smDefaultMsgId)
        hasher.combine(optionalParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBroadcastSmRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BroadcastSmRequest {
        return
            try BroadcastSmRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                serviceType: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                priorityFlag: FfiConverterUInt8.read(from: &buf), 
                scheduleDeliveryTime: FfiConverterOptionString.read(from: &buf), 
                validityPeriod: FfiConverterOptionString.read(from: &buf), 
                replaceIfPresentFlag: FfiConverterUInt8.read(from: &buf), 
                dataCoding: FfiConverterUInt8.read(from: &buf), 
                smDefaultMsgId: FfiConverterUInt8.read(from: &buf), 
                optionalParams: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: BroadcastSmRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.serviceType, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterUInt8.write(value.priorityFlag, into: &buf)
        FfiConverterOptionString.write(value.scheduleDeliveryTime, into: &buf)
        FfiConverterOptionString.write(value.validityPeriod, into: &buf)
        FfiConverterUInt8.write(value.replaceIfPresentFlag, into: &buf)
        FfiConverterUInt8.write(value.dataCoding, into: &buf)
        FfiConverterUInt8.write(value.smDefaultMsgId, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.optionalParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBroadcastSmRequest_lift(_ buf: RustBuffer) throws -> BroadcastSmRequest {
    return try FfiConverterTypeBroadcastSmRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBroadcastSmRequest_lower(_ value: BroadcastSmRequest) -> RustBuffer {
    return FfiConverterTypeBroadcastSmRequest.lower(value)
}


/**
 * Represents a Broadcast SM response.
 */
public struct BroadcastSmResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The status description.
     */
    public var statusDescription: String
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * Optional TLV parameters.
     */
    public var optionalParams: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The status description.
         */statusDescription: String, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * Optional TLV parameters.
         */optionalParams: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.statusDescription = statusDescription
        self.messageId = messageId
        self.optionalParams = optionalParams
    }
}



extension BroadcastSmResponse: Equatable, Hashable {
    public static func ==(lhs: BroadcastSmResponse, rhs: BroadcastSmResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.optionalParams != rhs.optionalParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(statusDescription)
        hasher.combine(messageId)
        hasher.combine(optionalParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBroadcastSmResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BroadcastSmResponse {
        return
            try BroadcastSmResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                optionalParams: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: BroadcastSmResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.optionalParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBroadcastSmResponse_lift(_ buf: RustBuffer) throws -> BroadcastSmResponse {
    return try FfiConverterTypeBroadcastSmResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBroadcastSmResponse_lower(_ value: BroadcastSmResponse) -> RustBuffer {
    return FfiConverterTypeBroadcastSmResponse.lower(value)
}


/**
 * Represents a Cancel Broadcast SM request.
 */
public struct CancelBroadcastSmRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The service type.
     */
    public var serviceType: String
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String
    /**
     * Optional TLV parameters.
     */
    public var optionalParams: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The service type.
         */serviceType: String, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String, 
        /**
         * Optional TLV parameters.
         */optionalParams: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.serviceType = serviceType
        self.messageId = messageId
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
        self.optionalParams = optionalParams
    }
}



extension CancelBroadcastSmRequest: Equatable, Hashable {
    public static func ==(lhs: CancelBroadcastSmRequest, rhs: CancelBroadcastSmRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.serviceType != rhs.serviceType {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        if lhs.optionalParams != rhs.optionalParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(serviceType)
        hasher.combine(messageId)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
        hasher.combine(optionalParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCancelBroadcastSmRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelBroadcastSmRequest {
        return
            try CancelBroadcastSmRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                serviceType: FfiConverterString.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf), 
                optionalParams: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: CancelBroadcastSmRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.serviceType, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.optionalParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelBroadcastSmRequest_lift(_ buf: RustBuffer) throws -> CancelBroadcastSmRequest {
    return try FfiConverterTypeCancelBroadcastSmRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelBroadcastSmRequest_lower(_ value: CancelBroadcastSmRequest) -> RustBuffer {
    return FfiConverterTypeCancelBroadcastSmRequest.lower(value)
}


/**
 * Represents a Cancel Broadcast SM response.
 */
public struct CancelBroadcastSmResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The status description.
     */
    public var statusDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The status description.
         */statusDescription: String) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.statusDescription = statusDescription
    }
}



extension CancelBroadcastSmResponse: Equatable, Hashable {
    public static func ==(lhs: CancelBroadcastSmResponse, rhs: CancelBroadcastSmResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(statusDescription)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCancelBroadcastSmResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelBroadcastSmResponse {
        return
            try CancelBroadcastSmResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CancelBroadcastSmResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelBroadcastSmResponse_lift(_ buf: RustBuffer) throws -> CancelBroadcastSmResponse {
    return try FfiConverterTypeCancelBroadcastSmResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelBroadcastSmResponse_lower(_ value: CancelBroadcastSmResponse) -> RustBuffer {
    return FfiConverterTypeCancelBroadcastSmResponse.lower(value)
}


/**
 * Represents a Cancel SM request.
 */
public struct CancelSmRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The service type.
     */
    public var serviceType: String
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String
    /**
     * Type of Number for destination address.
     */
    public var destAddrTon: Ton
    /**
     * Numbering Plan Indicator for destination address.
     */
    public var destAddrNpi: Npi
    /**
     * The destination address.
     */
    public var destAddr: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The service type.
         */serviceType: String, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String, 
        /**
         * Type of Number for destination address.
         */destAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for destination address.
         */destAddrNpi: Npi, 
        /**
         * The destination address.
         */destAddr: String) {
        self.sequenceNumber = sequenceNumber
        self.serviceType = serviceType
        self.messageId = messageId
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
        self.destAddrTon = destAddrTon
        self.destAddrNpi = destAddrNpi
        self.destAddr = destAddr
    }
}



extension CancelSmRequest: Equatable, Hashable {
    public static func ==(lhs: CancelSmRequest, rhs: CancelSmRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.serviceType != rhs.serviceType {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        if lhs.destAddrTon != rhs.destAddrTon {
            return false
        }
        if lhs.destAddrNpi != rhs.destAddrNpi {
            return false
        }
        if lhs.destAddr != rhs.destAddr {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(serviceType)
        hasher.combine(messageId)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
        hasher.combine(destAddrTon)
        hasher.combine(destAddrNpi)
        hasher.combine(destAddr)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCancelSmRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelSmRequest {
        return
            try CancelSmRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                serviceType: FfiConverterString.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf), 
                destAddrTon: FfiConverterTypeTon.read(from: &buf), 
                destAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                destAddr: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CancelSmRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.serviceType, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
        FfiConverterTypeTon.write(value.destAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.destAddrNpi, into: &buf)
        FfiConverterString.write(value.destAddr, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelSmRequest_lift(_ buf: RustBuffer) throws -> CancelSmRequest {
    return try FfiConverterTypeCancelSmRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelSmRequest_lower(_ value: CancelSmRequest) -> RustBuffer {
    return FfiConverterTypeCancelSmRequest.lower(value)
}


/**
 * Represents a Cancel SM response.
 */
public struct CancelSmResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The status description.
     */
    public var statusDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The status description.
         */statusDescription: String) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.statusDescription = statusDescription
    }
}



extension CancelSmResponse: Equatable, Hashable {
    public static func ==(lhs: CancelSmResponse, rhs: CancelSmResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(statusDescription)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCancelSmResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelSmResponse {
        return
            try CancelSmResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CancelSmResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelSmResponse_lift(_ buf: RustBuffer) throws -> CancelSmResponse {
    return try FfiConverterTypeCancelSmResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelSmResponse_lower(_ value: CancelSmResponse) -> RustBuffer {
    return FfiConverterTypeCancelSmResponse.lower(value)
}


/**
 * Represents a Data SM request.
 */
public struct DataSm {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The service type.
     */
    public var serviceType: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String
    /**
     * Type of Number for destination address.
     */
    public var destAddrTon: Ton
    /**
     * Numbering Plan Indicator for destination address.
     */
    public var destAddrNpi: Npi
    /**
     * The destination address.
     */
    public var destAddr: String
    /**
     * The ESM class.
     */
    public var esmClass: UInt8
    /**
     * The registered delivery flag.
     */
    public var registeredDelivery: UInt8
    /**
     * The data coding scheme.
     */
    public var dataCoding: UInt8
    /**
     * Optional TLV parameters.
     */
    public var optionalParams: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The service type.
         */serviceType: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String, 
        /**
         * Type of Number for destination address.
         */destAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for destination address.
         */destAddrNpi: Npi, 
        /**
         * The destination address.
         */destAddr: String, 
        /**
         * The ESM class.
         */esmClass: UInt8, 
        /**
         * The registered delivery flag.
         */registeredDelivery: UInt8, 
        /**
         * The data coding scheme.
         */dataCoding: UInt8, 
        /**
         * Optional TLV parameters.
         */optionalParams: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.serviceType = serviceType
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
        self.destAddrTon = destAddrTon
        self.destAddrNpi = destAddrNpi
        self.destAddr = destAddr
        self.esmClass = esmClass
        self.registeredDelivery = registeredDelivery
        self.dataCoding = dataCoding
        self.optionalParams = optionalParams
    }
}



extension DataSm: Equatable, Hashable {
    public static func ==(lhs: DataSm, rhs: DataSm) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.serviceType != rhs.serviceType {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        if lhs.destAddrTon != rhs.destAddrTon {
            return false
        }
        if lhs.destAddrNpi != rhs.destAddrNpi {
            return false
        }
        if lhs.destAddr != rhs.destAddr {
            return false
        }
        if lhs.esmClass != rhs.esmClass {
            return false
        }
        if lhs.registeredDelivery != rhs.registeredDelivery {
            return false
        }
        if lhs.dataCoding != rhs.dataCoding {
            return false
        }
        if lhs.optionalParams != rhs.optionalParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(serviceType)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
        hasher.combine(destAddrTon)
        hasher.combine(destAddrNpi)
        hasher.combine(destAddr)
        hasher.combine(esmClass)
        hasher.combine(registeredDelivery)
        hasher.combine(dataCoding)
        hasher.combine(optionalParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataSm: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataSm {
        return
            try DataSm(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                serviceType: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf), 
                destAddrTon: FfiConverterTypeTon.read(from: &buf), 
                destAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                destAddr: FfiConverterString.read(from: &buf), 
                esmClass: FfiConverterUInt8.read(from: &buf), 
                registeredDelivery: FfiConverterUInt8.read(from: &buf), 
                dataCoding: FfiConverterUInt8.read(from: &buf), 
                optionalParams: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: DataSm, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.serviceType, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
        FfiConverterTypeTon.write(value.destAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.destAddrNpi, into: &buf)
        FfiConverterString.write(value.destAddr, into: &buf)
        FfiConverterUInt8.write(value.esmClass, into: &buf)
        FfiConverterUInt8.write(value.registeredDelivery, into: &buf)
        FfiConverterUInt8.write(value.dataCoding, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.optionalParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataSm_lift(_ buf: RustBuffer) throws -> DataSm {
    return try FfiConverterTypeDataSm.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataSm_lower(_ value: DataSm) -> RustBuffer {
    return FfiConverterTypeDataSm.lower(value)
}


/**
 * Represents a Data SM response.
 */
public struct DataSmResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * The status description.
     */
    public var statusDescription: String
    /**
     * Optional TLV parameters.
     */
    public var optionalParams: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * The status description.
         */statusDescription: String, 
        /**
         * Optional TLV parameters.
         */optionalParams: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.messageId = messageId
        self.statusDescription = statusDescription
        self.optionalParams = optionalParams
    }
}



extension DataSmResponse: Equatable, Hashable {
    public static func ==(lhs: DataSmResponse, rhs: DataSmResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        if lhs.optionalParams != rhs.optionalParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(messageId)
        hasher.combine(statusDescription)
        hasher.combine(optionalParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataSmResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataSmResponse {
        return
            try DataSmResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf), 
                optionalParams: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: DataSmResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.optionalParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataSmResponse_lift(_ buf: RustBuffer) throws -> DataSmResponse {
    return try FfiConverterTypeDataSmResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataSmResponse_lower(_ value: DataSmResponse) -> RustBuffer {
    return FfiConverterTypeDataSmResponse.lower(value)
}


/**
 * Represents a Deliver SM request.
 */
public struct DeliverSmRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The service type.
     */
    public var serviceType: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String
    /**
     * Type of Number for destination address.
     */
    public var destAddrTon: Ton
    /**
     * Numbering Plan Indicator for destination address.
     */
    public var destAddrNpi: Npi
    /**
     * The destination address.
     */
    public var destAddr: String
    /**
     * The ESM class.
     */
    public var esmClass: UInt8
    /**
     * The protocol ID.
     */
    public var protocolId: UInt8
    /**
     * The priority flag.
     */
    public var priorityFlag: UInt8
    /**
     * The schedule delivery time.
     */
    public var scheduleDeliveryTime: String?
    /**
     * The validity period.
     */
    public var validityPeriod: String?
    /**
     * The registered delivery flag.
     */
    public var registeredDelivery: UInt8
    /**
     * The replace if present flag.
     */
    public var replaceIfPresentFlag: UInt8
    /**
     * The data coding scheme.
     */
    public var dataCoding: UInt8
    /**
     * The default message ID.
     */
    public var smDefaultMsgId: UInt8
    /**
     * The short message content.
     */
    public var shortMessage: Data
    /**
     * Optional TLV parameters.
     */
    public var optionalParams: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The service type.
         */serviceType: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String, 
        /**
         * Type of Number for destination address.
         */destAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for destination address.
         */destAddrNpi: Npi, 
        /**
         * The destination address.
         */destAddr: String, 
        /**
         * The ESM class.
         */esmClass: UInt8, 
        /**
         * The protocol ID.
         */protocolId: UInt8, 
        /**
         * The priority flag.
         */priorityFlag: UInt8, 
        /**
         * The schedule delivery time.
         */scheduleDeliveryTime: String?, 
        /**
         * The validity period.
         */validityPeriod: String?, 
        /**
         * The registered delivery flag.
         */registeredDelivery: UInt8, 
        /**
         * The replace if present flag.
         */replaceIfPresentFlag: UInt8, 
        /**
         * The data coding scheme.
         */dataCoding: UInt8, 
        /**
         * The default message ID.
         */smDefaultMsgId: UInt8, 
        /**
         * The short message content.
         */shortMessage: Data, 
        /**
         * Optional TLV parameters.
         */optionalParams: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.serviceType = serviceType
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
        self.destAddrTon = destAddrTon
        self.destAddrNpi = destAddrNpi
        self.destAddr = destAddr
        self.esmClass = esmClass
        self.protocolId = protocolId
        self.priorityFlag = priorityFlag
        self.scheduleDeliveryTime = scheduleDeliveryTime
        self.validityPeriod = validityPeriod
        self.registeredDelivery = registeredDelivery
        self.replaceIfPresentFlag = replaceIfPresentFlag
        self.dataCoding = dataCoding
        self.smDefaultMsgId = smDefaultMsgId
        self.shortMessage = shortMessage
        self.optionalParams = optionalParams
    }
}



extension DeliverSmRequest: Equatable, Hashable {
    public static func ==(lhs: DeliverSmRequest, rhs: DeliverSmRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.serviceType != rhs.serviceType {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        if lhs.destAddrTon != rhs.destAddrTon {
            return false
        }
        if lhs.destAddrNpi != rhs.destAddrNpi {
            return false
        }
        if lhs.destAddr != rhs.destAddr {
            return false
        }
        if lhs.esmClass != rhs.esmClass {
            return false
        }
        if lhs.protocolId != rhs.protocolId {
            return false
        }
        if lhs.priorityFlag != rhs.priorityFlag {
            return false
        }
        if lhs.scheduleDeliveryTime != rhs.scheduleDeliveryTime {
            return false
        }
        if lhs.validityPeriod != rhs.validityPeriod {
            return false
        }
        if lhs.registeredDelivery != rhs.registeredDelivery {
            return false
        }
        if lhs.replaceIfPresentFlag != rhs.replaceIfPresentFlag {
            return false
        }
        if lhs.dataCoding != rhs.dataCoding {
            return false
        }
        if lhs.smDefaultMsgId != rhs.smDefaultMsgId {
            return false
        }
        if lhs.shortMessage != rhs.shortMessage {
            return false
        }
        if lhs.optionalParams != rhs.optionalParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(serviceType)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
        hasher.combine(destAddrTon)
        hasher.combine(destAddrNpi)
        hasher.combine(destAddr)
        hasher.combine(esmClass)
        hasher.combine(protocolId)
        hasher.combine(priorityFlag)
        hasher.combine(scheduleDeliveryTime)
        hasher.combine(validityPeriod)
        hasher.combine(registeredDelivery)
        hasher.combine(replaceIfPresentFlag)
        hasher.combine(dataCoding)
        hasher.combine(smDefaultMsgId)
        hasher.combine(shortMessage)
        hasher.combine(optionalParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeliverSmRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeliverSmRequest {
        return
            try DeliverSmRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                serviceType: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf), 
                destAddrTon: FfiConverterTypeTon.read(from: &buf), 
                destAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                destAddr: FfiConverterString.read(from: &buf), 
                esmClass: FfiConverterUInt8.read(from: &buf), 
                protocolId: FfiConverterUInt8.read(from: &buf), 
                priorityFlag: FfiConverterUInt8.read(from: &buf), 
                scheduleDeliveryTime: FfiConverterOptionString.read(from: &buf), 
                validityPeriod: FfiConverterOptionString.read(from: &buf), 
                registeredDelivery: FfiConverterUInt8.read(from: &buf), 
                replaceIfPresentFlag: FfiConverterUInt8.read(from: &buf), 
                dataCoding: FfiConverterUInt8.read(from: &buf), 
                smDefaultMsgId: FfiConverterUInt8.read(from: &buf), 
                shortMessage: FfiConverterData.read(from: &buf), 
                optionalParams: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: DeliverSmRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.serviceType, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
        FfiConverterTypeTon.write(value.destAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.destAddrNpi, into: &buf)
        FfiConverterString.write(value.destAddr, into: &buf)
        FfiConverterUInt8.write(value.esmClass, into: &buf)
        FfiConverterUInt8.write(value.protocolId, into: &buf)
        FfiConverterUInt8.write(value.priorityFlag, into: &buf)
        FfiConverterOptionString.write(value.scheduleDeliveryTime, into: &buf)
        FfiConverterOptionString.write(value.validityPeriod, into: &buf)
        FfiConverterUInt8.write(value.registeredDelivery, into: &buf)
        FfiConverterUInt8.write(value.replaceIfPresentFlag, into: &buf)
        FfiConverterUInt8.write(value.dataCoding, into: &buf)
        FfiConverterUInt8.write(value.smDefaultMsgId, into: &buf)
        FfiConverterData.write(value.shortMessage, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.optionalParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeliverSmRequest_lift(_ buf: RustBuffer) throws -> DeliverSmRequest {
    return try FfiConverterTypeDeliverSmRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeliverSmRequest_lower(_ value: DeliverSmRequest) -> RustBuffer {
    return FfiConverterTypeDeliverSmRequest.lower(value)
}


/**
 * Represents a Deliver SM response.
 */
public struct DeliverSmResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * The status description.
     */
    public var statusDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * The status description.
         */statusDescription: String) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.messageId = messageId
        self.statusDescription = statusDescription
    }
}



extension DeliverSmResponse: Equatable, Hashable {
    public static func ==(lhs: DeliverSmResponse, rhs: DeliverSmResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(messageId)
        hasher.combine(statusDescription)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeliverSmResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeliverSmResponse {
        return
            try DeliverSmResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DeliverSmResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeliverSmResponse_lift(_ buf: RustBuffer) throws -> DeliverSmResponse {
    return try FfiConverterTypeDeliverSmResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeliverSmResponse_lower(_ value: DeliverSmResponse) -> RustBuffer {
    return FfiConverterTypeDeliverSmResponse.lower(value)
}


/**
 * Represents a Delivery Receipt.
 */
public struct DeliveryReceipt {
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * The number of messages submitted.
     */
    public var submittedCount: UInt32
    /**
     * The number of messages delivered.
     */
    public var deliveredCount: UInt32
    /**
     * The time the message was submitted.
     */
    public var submitDate: String
    /**
     * The time the message was done.
     */
    public var doneDate: String
    /**
     * The final status.
     */
    public var status: String
    /**
     * The error code, if any.
     */
    public var errorCode: UInt32
    /**
     * The text of the receipt.
     */
    public var text: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The message ID.
         */messageId: String, 
        /**
         * The number of messages submitted.
         */submittedCount: UInt32, 
        /**
         * The number of messages delivered.
         */deliveredCount: UInt32, 
        /**
         * The time the message was submitted.
         */submitDate: String, 
        /**
         * The time the message was done.
         */doneDate: String, 
        /**
         * The final status.
         */status: String, 
        /**
         * The error code, if any.
         */errorCode: UInt32, 
        /**
         * The text of the receipt.
         */text: String) {
        self.messageId = messageId
        self.submittedCount = submittedCount
        self.deliveredCount = deliveredCount
        self.submitDate = submitDate
        self.doneDate = doneDate
        self.status = status
        self.errorCode = errorCode
        self.text = text
    }
}



extension DeliveryReceipt: Equatable, Hashable {
    public static func ==(lhs: DeliveryReceipt, rhs: DeliveryReceipt) -> Bool {
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.submittedCount != rhs.submittedCount {
            return false
        }
        if lhs.deliveredCount != rhs.deliveredCount {
            return false
        }
        if lhs.submitDate != rhs.submitDate {
            return false
        }
        if lhs.doneDate != rhs.doneDate {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.errorCode != rhs.errorCode {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageId)
        hasher.combine(submittedCount)
        hasher.combine(deliveredCount)
        hasher.combine(submitDate)
        hasher.combine(doneDate)
        hasher.combine(status)
        hasher.combine(errorCode)
        hasher.combine(text)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeliveryReceipt: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeliveryReceipt {
        return
            try DeliveryReceipt(
                messageId: FfiConverterString.read(from: &buf), 
                submittedCount: FfiConverterUInt32.read(from: &buf), 
                deliveredCount: FfiConverterUInt32.read(from: &buf), 
                submitDate: FfiConverterString.read(from: &buf), 
                doneDate: FfiConverterString.read(from: &buf), 
                status: FfiConverterString.read(from: &buf), 
                errorCode: FfiConverterUInt32.read(from: &buf), 
                text: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DeliveryReceipt, into buf: inout [UInt8]) {
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterUInt32.write(value.submittedCount, into: &buf)
        FfiConverterUInt32.write(value.deliveredCount, into: &buf)
        FfiConverterString.write(value.submitDate, into: &buf)
        FfiConverterString.write(value.doneDate, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterUInt32.write(value.errorCode, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeliveryReceipt_lift(_ buf: RustBuffer) throws -> DeliveryReceipt {
    return try FfiConverterTypeDeliveryReceipt.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeliveryReceipt_lower(_ value: DeliveryReceipt) -> RustBuffer {
    return FfiConverterTypeDeliveryReceipt.lower(value)
}


/**
 * Represents an Enquire Link request.
 */
public struct EnquireLink {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32) {
        self.sequenceNumber = sequenceNumber
    }
}



extension EnquireLink: Equatable, Hashable {
    public static func ==(lhs: EnquireLink, rhs: EnquireLink) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnquireLink: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnquireLink {
        return
            try EnquireLink(
                sequenceNumber: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: EnquireLink, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnquireLink_lift(_ buf: RustBuffer) throws -> EnquireLink {
    return try FfiConverterTypeEnquireLink.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnquireLink_lower(_ value: EnquireLink) -> RustBuffer {
    return FfiConverterTypeEnquireLink.lower(value)
}


/**
 * Represents an Enquire Link response.
 */
public struct EnquireLinkResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
    }
}



extension EnquireLinkResponse: Equatable, Hashable {
    public static func ==(lhs: EnquireLinkResponse, rhs: EnquireLinkResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnquireLinkResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnquireLinkResponse {
        return
            try EnquireLinkResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: EnquireLinkResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnquireLinkResponse_lift(_ buf: RustBuffer) throws -> EnquireLinkResponse {
    return try FfiConverterTypeEnquireLinkResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnquireLinkResponse_lower(_ value: EnquireLinkResponse) -> RustBuffer {
    return FfiConverterTypeEnquireLinkResponse.lower(value)
}


/**
 * Represents a Generic Nack response.
 */
public struct GenericNack {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
    }
}



extension GenericNack: Equatable, Hashable {
    public static func ==(lhs: GenericNack, rhs: GenericNack) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGenericNack: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GenericNack {
        return
            try GenericNack(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: GenericNack, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericNack_lift(_ buf: RustBuffer) throws -> GenericNack {
    return try FfiConverterTypeGenericNack.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericNack_lower(_ value: GenericNack) -> RustBuffer {
    return FfiConverterTypeGenericNack.lower(value)
}


/**
 * Represents an Outbind request.
 */
public struct Outbind {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The system_id.
     */
    public var systemId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The system_id.
         */systemId: String) {
        self.sequenceNumber = sequenceNumber
        self.systemId = systemId
    }
}



extension Outbind: Equatable, Hashable {
    public static func ==(lhs: Outbind, rhs: Outbind) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.systemId != rhs.systemId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(systemId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutbind: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Outbind {
        return
            try Outbind(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                systemId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Outbind, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.systemId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutbind_lift(_ buf: RustBuffer) throws -> Outbind {
    return try FfiConverterTypeOutbind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutbind_lower(_ value: Outbind) -> RustBuffer {
    return FfiConverterTypeOutbind.lower(value)
}


/**
 * Represents a Query Broadcast SM request.
 */
public struct QueryBroadcastSmRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String
    /**
     * Optional TLV parameters.
     */
    public var optionalParams: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String, 
        /**
         * Optional TLV parameters.
         */optionalParams: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.messageId = messageId
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
        self.optionalParams = optionalParams
    }
}



extension QueryBroadcastSmRequest: Equatable, Hashable {
    public static func ==(lhs: QueryBroadcastSmRequest, rhs: QueryBroadcastSmRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        if lhs.optionalParams != rhs.optionalParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(messageId)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
        hasher.combine(optionalParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQueryBroadcastSmRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QueryBroadcastSmRequest {
        return
            try QueryBroadcastSmRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf), 
                optionalParams: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: QueryBroadcastSmRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.optionalParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueryBroadcastSmRequest_lift(_ buf: RustBuffer) throws -> QueryBroadcastSmRequest {
    return try FfiConverterTypeQueryBroadcastSmRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueryBroadcastSmRequest_lower(_ value: QueryBroadcastSmRequest) -> RustBuffer {
    return FfiConverterTypeQueryBroadcastSmRequest.lower(value)
}


/**
 * Represents a Query Broadcast SM response.
 */
public struct QueryBroadcastSmResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The status description.
     */
    public var statusDescription: String
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * Optional TLV parameters.
     */
    public var optionalParams: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The status description.
         */statusDescription: String, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * Optional TLV parameters.
         */optionalParams: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.statusDescription = statusDescription
        self.messageId = messageId
        self.optionalParams = optionalParams
    }
}



extension QueryBroadcastSmResponse: Equatable, Hashable {
    public static func ==(lhs: QueryBroadcastSmResponse, rhs: QueryBroadcastSmResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.optionalParams != rhs.optionalParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(statusDescription)
        hasher.combine(messageId)
        hasher.combine(optionalParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQueryBroadcastSmResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QueryBroadcastSmResponse {
        return
            try QueryBroadcastSmResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                optionalParams: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: QueryBroadcastSmResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.optionalParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueryBroadcastSmResponse_lift(_ buf: RustBuffer) throws -> QueryBroadcastSmResponse {
    return try FfiConverterTypeQueryBroadcastSmResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueryBroadcastSmResponse_lower(_ value: QueryBroadcastSmResponse) -> RustBuffer {
    return FfiConverterTypeQueryBroadcastSmResponse.lower(value)
}


/**
 * Represents a Query SM request.
 */
public struct QuerySmRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String) {
        self.sequenceNumber = sequenceNumber
        self.messageId = messageId
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
    }
}



extension QuerySmRequest: Equatable, Hashable {
    public static func ==(lhs: QuerySmRequest, rhs: QuerySmRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(messageId)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQuerySmRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QuerySmRequest {
        return
            try QuerySmRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: QuerySmRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuerySmRequest_lift(_ buf: RustBuffer) throws -> QuerySmRequest {
    return try FfiConverterTypeQuerySmRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuerySmRequest_lower(_ value: QuerySmRequest) -> RustBuffer {
    return FfiConverterTypeQuerySmRequest.lower(value)
}


/**
 * Represents a Query SM response.
 */
public struct QuerySmResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * The final date.
     */
    public var finalDate: String
    /**
     * The message state.
     */
    public var messageState: UInt8
    /**
     * The error code.
     */
    public var errorCode: UInt8
    /**
     * The status description.
     */
    public var statusDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * The final date.
         */finalDate: String, 
        /**
         * The message state.
         */messageState: UInt8, 
        /**
         * The error code.
         */errorCode: UInt8, 
        /**
         * The status description.
         */statusDescription: String) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.messageId = messageId
        self.finalDate = finalDate
        self.messageState = messageState
        self.errorCode = errorCode
        self.statusDescription = statusDescription
    }
}



extension QuerySmResponse: Equatable, Hashable {
    public static func ==(lhs: QuerySmResponse, rhs: QuerySmResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.finalDate != rhs.finalDate {
            return false
        }
        if lhs.messageState != rhs.messageState {
            return false
        }
        if lhs.errorCode != rhs.errorCode {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(messageId)
        hasher.combine(finalDate)
        hasher.combine(messageState)
        hasher.combine(errorCode)
        hasher.combine(statusDescription)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQuerySmResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QuerySmResponse {
        return
            try QuerySmResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                finalDate: FfiConverterString.read(from: &buf), 
                messageState: FfiConverterUInt8.read(from: &buf), 
                errorCode: FfiConverterUInt8.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: QuerySmResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterString.write(value.finalDate, into: &buf)
        FfiConverterUInt8.write(value.messageState, into: &buf)
        FfiConverterUInt8.write(value.errorCode, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuerySmResponse_lift(_ buf: RustBuffer) throws -> QuerySmResponse {
    return try FfiConverterTypeQuerySmResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuerySmResponse_lower(_ value: QuerySmResponse) -> RustBuffer {
    return FfiConverterTypeQuerySmResponse.lower(value)
}


/**
 * Represents a Replace SM request.
 */
public struct ReplaceSmRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String
    /**
     * The schedule delivery time.
     */
    public var scheduleDeliveryTime: String
    /**
     * The validity period.
     */
    public var validityPeriod: String
    /**
     * The registered delivery flag.
     */
    public var registeredDelivery: UInt8
    /**
     * The default message ID.
     */
    public var smDefaultMsgId: UInt8
    /**
     * The short message content.
     */
    public var shortMessage: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String, 
        /**
         * The schedule delivery time.
         */scheduleDeliveryTime: String, 
        /**
         * The validity period.
         */validityPeriod: String, 
        /**
         * The registered delivery flag.
         */registeredDelivery: UInt8, 
        /**
         * The default message ID.
         */smDefaultMsgId: UInt8, 
        /**
         * The short message content.
         */shortMessage: Data) {
        self.sequenceNumber = sequenceNumber
        self.messageId = messageId
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
        self.scheduleDeliveryTime = scheduleDeliveryTime
        self.validityPeriod = validityPeriod
        self.registeredDelivery = registeredDelivery
        self.smDefaultMsgId = smDefaultMsgId
        self.shortMessage = shortMessage
    }
}



extension ReplaceSmRequest: Equatable, Hashable {
    public static func ==(lhs: ReplaceSmRequest, rhs: ReplaceSmRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        if lhs.scheduleDeliveryTime != rhs.scheduleDeliveryTime {
            return false
        }
        if lhs.validityPeriod != rhs.validityPeriod {
            return false
        }
        if lhs.registeredDelivery != rhs.registeredDelivery {
            return false
        }
        if lhs.smDefaultMsgId != rhs.smDefaultMsgId {
            return false
        }
        if lhs.shortMessage != rhs.shortMessage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(messageId)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
        hasher.combine(scheduleDeliveryTime)
        hasher.combine(validityPeriod)
        hasher.combine(registeredDelivery)
        hasher.combine(smDefaultMsgId)
        hasher.combine(shortMessage)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReplaceSmRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReplaceSmRequest {
        return
            try ReplaceSmRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf), 
                scheduleDeliveryTime: FfiConverterString.read(from: &buf), 
                validityPeriod: FfiConverterString.read(from: &buf), 
                registeredDelivery: FfiConverterUInt8.read(from: &buf), 
                smDefaultMsgId: FfiConverterUInt8.read(from: &buf), 
                shortMessage: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ReplaceSmRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
        FfiConverterString.write(value.scheduleDeliveryTime, into: &buf)
        FfiConverterString.write(value.validityPeriod, into: &buf)
        FfiConverterUInt8.write(value.registeredDelivery, into: &buf)
        FfiConverterUInt8.write(value.smDefaultMsgId, into: &buf)
        FfiConverterData.write(value.shortMessage, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReplaceSmRequest_lift(_ buf: RustBuffer) throws -> ReplaceSmRequest {
    return try FfiConverterTypeReplaceSmRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReplaceSmRequest_lower(_ value: ReplaceSmRequest) -> RustBuffer {
    return FfiConverterTypeReplaceSmRequest.lower(value)
}


/**
 * Represents a Replace SM response.
 */
public struct ReplaceSmResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The status description.
     */
    public var statusDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The status description.
         */statusDescription: String) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.statusDescription = statusDescription
    }
}



extension ReplaceSmResponse: Equatable, Hashable {
    public static func ==(lhs: ReplaceSmResponse, rhs: ReplaceSmResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(statusDescription)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReplaceSmResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReplaceSmResponse {
        return
            try ReplaceSmResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ReplaceSmResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReplaceSmResponse_lift(_ buf: RustBuffer) throws -> ReplaceSmResponse {
    return try FfiConverterTypeReplaceSmResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReplaceSmResponse_lower(_ value: ReplaceSmResponse) -> RustBuffer {
    return FfiConverterTypeReplaceSmResponse.lower(value)
}


/**
 * Result of message splitting.
 */
public struct SplitResult {
    /**
     * The parts of the split message.
     */
    public var parts: [Data]
    /**
     * The data coding used.
     */
    public var dataCoding: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The parts of the split message.
         */parts: [Data], 
        /**
         * The data coding used.
         */dataCoding: UInt8) {
        self.parts = parts
        self.dataCoding = dataCoding
    }
}



extension SplitResult: Equatable, Hashable {
    public static func ==(lhs: SplitResult, rhs: SplitResult) -> Bool {
        if lhs.parts != rhs.parts {
            return false
        }
        if lhs.dataCoding != rhs.dataCoding {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(parts)
        hasher.combine(dataCoding)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSplitResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SplitResult {
        return
            try SplitResult(
                parts: FfiConverterSequenceData.read(from: &buf), 
                dataCoding: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: SplitResult, into buf: inout [UInt8]) {
        FfiConverterSequenceData.write(value.parts, into: &buf)
        FfiConverterUInt8.write(value.dataCoding, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSplitResult_lift(_ buf: RustBuffer) throws -> SplitResult {
    return try FfiConverterTypeSplitResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSplitResult_lower(_ value: SplitResult) -> RustBuffer {
    return FfiConverterTypeSplitResult.lower(value)
}


/**
 * Represents a Submit Multi request.
 */
public struct SubmitMultiRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The service type.
     */
    public var serviceType: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String
    /**
     * List of destinations (SME addresses or Distribution Lists).
     */
    public var destinations: [Destination]
    /**
     * The ESM class.
     */
    public var esmClass: UInt8
    /**
     * The protocol ID.
     */
    public var protocolId: UInt8
    /**
     * The priority flag.
     */
    public var priorityFlag: UInt8
    /**
     * The schedule delivery time.
     */
    public var scheduleDeliveryTime: String?
    /**
     * The validity period.
     */
    public var validityPeriod: String?
    /**
     * The registered delivery flag.
     */
    public var registeredDelivery: UInt8
    /**
     * The replace if present flag.
     */
    public var replaceIfPresentFlag: UInt8
    /**
     * The data coding scheme.
     */
    public var dataCoding: UInt8
    /**
     * The default message ID.
     */
    public var smDefaultMsgId: UInt8
    /**
     * The short message content.
     */
    public var shortMessage: Data
    /**
     * Optional TLV parameters.
     */
    public var tlvs: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The service type.
         */serviceType: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String, 
        /**
         * List of destinations (SME addresses or Distribution Lists).
         */destinations: [Destination], 
        /**
         * The ESM class.
         */esmClass: UInt8, 
        /**
         * The protocol ID.
         */protocolId: UInt8, 
        /**
         * The priority flag.
         */priorityFlag: UInt8, 
        /**
         * The schedule delivery time.
         */scheduleDeliveryTime: String?, 
        /**
         * The validity period.
         */validityPeriod: String?, 
        /**
         * The registered delivery flag.
         */registeredDelivery: UInt8, 
        /**
         * The replace if present flag.
         */replaceIfPresentFlag: UInt8, 
        /**
         * The data coding scheme.
         */dataCoding: UInt8, 
        /**
         * The default message ID.
         */smDefaultMsgId: UInt8, 
        /**
         * The short message content.
         */shortMessage: Data, 
        /**
         * Optional TLV parameters.
         */tlvs: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.serviceType = serviceType
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
        self.destinations = destinations
        self.esmClass = esmClass
        self.protocolId = protocolId
        self.priorityFlag = priorityFlag
        self.scheduleDeliveryTime = scheduleDeliveryTime
        self.validityPeriod = validityPeriod
        self.registeredDelivery = registeredDelivery
        self.replaceIfPresentFlag = replaceIfPresentFlag
        self.dataCoding = dataCoding
        self.smDefaultMsgId = smDefaultMsgId
        self.shortMessage = shortMessage
        self.tlvs = tlvs
    }
}



extension SubmitMultiRequest: Equatable, Hashable {
    public static func ==(lhs: SubmitMultiRequest, rhs: SubmitMultiRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.serviceType != rhs.serviceType {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        if lhs.destinations != rhs.destinations {
            return false
        }
        if lhs.esmClass != rhs.esmClass {
            return false
        }
        if lhs.protocolId != rhs.protocolId {
            return false
        }
        if lhs.priorityFlag != rhs.priorityFlag {
            return false
        }
        if lhs.scheduleDeliveryTime != rhs.scheduleDeliveryTime {
            return false
        }
        if lhs.validityPeriod != rhs.validityPeriod {
            return false
        }
        if lhs.registeredDelivery != rhs.registeredDelivery {
            return false
        }
        if lhs.replaceIfPresentFlag != rhs.replaceIfPresentFlag {
            return false
        }
        if lhs.dataCoding != rhs.dataCoding {
            return false
        }
        if lhs.smDefaultMsgId != rhs.smDefaultMsgId {
            return false
        }
        if lhs.shortMessage != rhs.shortMessage {
            return false
        }
        if lhs.tlvs != rhs.tlvs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(serviceType)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
        hasher.combine(destinations)
        hasher.combine(esmClass)
        hasher.combine(protocolId)
        hasher.combine(priorityFlag)
        hasher.combine(scheduleDeliveryTime)
        hasher.combine(validityPeriod)
        hasher.combine(registeredDelivery)
        hasher.combine(replaceIfPresentFlag)
        hasher.combine(dataCoding)
        hasher.combine(smDefaultMsgId)
        hasher.combine(shortMessage)
        hasher.combine(tlvs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubmitMultiRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubmitMultiRequest {
        return
            try SubmitMultiRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                serviceType: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf), 
                destinations: FfiConverterSequenceTypeDestination.read(from: &buf), 
                esmClass: FfiConverterUInt8.read(from: &buf), 
                protocolId: FfiConverterUInt8.read(from: &buf), 
                priorityFlag: FfiConverterUInt8.read(from: &buf), 
                scheduleDeliveryTime: FfiConverterOptionString.read(from: &buf), 
                validityPeriod: FfiConverterOptionString.read(from: &buf), 
                registeredDelivery: FfiConverterUInt8.read(from: &buf), 
                replaceIfPresentFlag: FfiConverterUInt8.read(from: &buf), 
                dataCoding: FfiConverterUInt8.read(from: &buf), 
                smDefaultMsgId: FfiConverterUInt8.read(from: &buf), 
                shortMessage: FfiConverterData.read(from: &buf), 
                tlvs: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: SubmitMultiRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.serviceType, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
        FfiConverterSequenceTypeDestination.write(value.destinations, into: &buf)
        FfiConverterUInt8.write(value.esmClass, into: &buf)
        FfiConverterUInt8.write(value.protocolId, into: &buf)
        FfiConverterUInt8.write(value.priorityFlag, into: &buf)
        FfiConverterOptionString.write(value.scheduleDeliveryTime, into: &buf)
        FfiConverterOptionString.write(value.validityPeriod, into: &buf)
        FfiConverterUInt8.write(value.registeredDelivery, into: &buf)
        FfiConverterUInt8.write(value.replaceIfPresentFlag, into: &buf)
        FfiConverterUInt8.write(value.dataCoding, into: &buf)
        FfiConverterUInt8.write(value.smDefaultMsgId, into: &buf)
        FfiConverterData.write(value.shortMessage, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.tlvs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubmitMultiRequest_lift(_ buf: RustBuffer) throws -> SubmitMultiRequest {
    return try FfiConverterTypeSubmitMultiRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubmitMultiRequest_lower(_ value: SubmitMultiRequest) -> RustBuffer {
    return FfiConverterTypeSubmitMultiRequest.lower(value)
}


/**
 * Represents a Submit Multi response.
 */
public struct SubmitMultiResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * The status description.
     */
    public var statusDescription: String
    /**
     * List of unsuccessful deliveries.
     */
    public var unsuccessSmes: [UnsuccessfulDelivery]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * The status description.
         */statusDescription: String, 
        /**
         * List of unsuccessful deliveries.
         */unsuccessSmes: [UnsuccessfulDelivery]) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.messageId = messageId
        self.statusDescription = statusDescription
        self.unsuccessSmes = unsuccessSmes
    }
}



extension SubmitMultiResponse: Equatable, Hashable {
    public static func ==(lhs: SubmitMultiResponse, rhs: SubmitMultiResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        if lhs.unsuccessSmes != rhs.unsuccessSmes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(messageId)
        hasher.combine(statusDescription)
        hasher.combine(unsuccessSmes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubmitMultiResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubmitMultiResponse {
        return
            try SubmitMultiResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf), 
                unsuccessSmes: FfiConverterSequenceTypeUnsuccessfulDelivery.read(from: &buf)
        )
    }

    public static func write(_ value: SubmitMultiResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
        FfiConverterSequenceTypeUnsuccessfulDelivery.write(value.unsuccessSmes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubmitMultiResponse_lift(_ buf: RustBuffer) throws -> SubmitMultiResponse {
    return try FfiConverterTypeSubmitMultiResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubmitMultiResponse_lower(_ value: SubmitMultiResponse) -> RustBuffer {
    return FfiConverterTypeSubmitMultiResponse.lower(value)
}


/**
 * Represents a Submit SM request.
 */
public struct SubmitSmRequest {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The service type.
     */
    public var serviceType: String
    /**
     * Type of Number for source address.
     */
    public var sourceAddrTon: Ton
    /**
     * Numbering Plan Indicator for source address.
     */
    public var sourceAddrNpi: Npi
    /**
     * The source address.
     */
    public var sourceAddr: String
    /**
     * Type of Number for destination address.
     */
    public var destAddrTon: Ton
    /**
     * Numbering Plan Indicator for destination address.
     */
    public var destAddrNpi: Npi
    /**
     * The destination address.
     */
    public var destinationAddr: String
    /**
     * The ESM class.
     */
    public var esmClass: UInt8
    /**
     * The protocol ID.
     */
    public var protocolId: UInt8
    /**
     * The priority flag.
     */
    public var priorityFlag: UInt8
    /**
     * The schedule delivery time.
     */
    public var scheduleDeliveryTime: String?
    /**
     * The validity period.
     */
    public var validityPeriod: String?
    /**
     * The registered delivery flag.
     */
    public var registeredDelivery: UInt8
    /**
     * The replace if present flag.
     */
    public var replaceIfPresentFlag: UInt8
    /**
     * The data coding scheme.
     */
    public var dataCoding: UInt8
    /**
     * The default message ID.
     */
    public var smDefaultMsgId: UInt8
    /**
     * The short message content.
     */
    public var shortMessage: Data
    /**
     * Optional TLV parameters.
     */
    public var tlvs: [Tlv]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The service type.
         */serviceType: String, 
        /**
         * Type of Number for source address.
         */sourceAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for source address.
         */sourceAddrNpi: Npi, 
        /**
         * The source address.
         */sourceAddr: String, 
        /**
         * Type of Number for destination address.
         */destAddrTon: Ton, 
        /**
         * Numbering Plan Indicator for destination address.
         */destAddrNpi: Npi, 
        /**
         * The destination address.
         */destinationAddr: String, 
        /**
         * The ESM class.
         */esmClass: UInt8, 
        /**
         * The protocol ID.
         */protocolId: UInt8, 
        /**
         * The priority flag.
         */priorityFlag: UInt8, 
        /**
         * The schedule delivery time.
         */scheduleDeliveryTime: String?, 
        /**
         * The validity period.
         */validityPeriod: String?, 
        /**
         * The registered delivery flag.
         */registeredDelivery: UInt8, 
        /**
         * The replace if present flag.
         */replaceIfPresentFlag: UInt8, 
        /**
         * The data coding scheme.
         */dataCoding: UInt8, 
        /**
         * The default message ID.
         */smDefaultMsgId: UInt8, 
        /**
         * The short message content.
         */shortMessage: Data, 
        /**
         * Optional TLV parameters.
         */tlvs: [Tlv]) {
        self.sequenceNumber = sequenceNumber
        self.serviceType = serviceType
        self.sourceAddrTon = sourceAddrTon
        self.sourceAddrNpi = sourceAddrNpi
        self.sourceAddr = sourceAddr
        self.destAddrTon = destAddrTon
        self.destAddrNpi = destAddrNpi
        self.destinationAddr = destinationAddr
        self.esmClass = esmClass
        self.protocolId = protocolId
        self.priorityFlag = priorityFlag
        self.scheduleDeliveryTime = scheduleDeliveryTime
        self.validityPeriod = validityPeriod
        self.registeredDelivery = registeredDelivery
        self.replaceIfPresentFlag = replaceIfPresentFlag
        self.dataCoding = dataCoding
        self.smDefaultMsgId = smDefaultMsgId
        self.shortMessage = shortMessage
        self.tlvs = tlvs
    }
}



extension SubmitSmRequest: Equatable, Hashable {
    public static func ==(lhs: SubmitSmRequest, rhs: SubmitSmRequest) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.serviceType != rhs.serviceType {
            return false
        }
        if lhs.sourceAddrTon != rhs.sourceAddrTon {
            return false
        }
        if lhs.sourceAddrNpi != rhs.sourceAddrNpi {
            return false
        }
        if lhs.sourceAddr != rhs.sourceAddr {
            return false
        }
        if lhs.destAddrTon != rhs.destAddrTon {
            return false
        }
        if lhs.destAddrNpi != rhs.destAddrNpi {
            return false
        }
        if lhs.destinationAddr != rhs.destinationAddr {
            return false
        }
        if lhs.esmClass != rhs.esmClass {
            return false
        }
        if lhs.protocolId != rhs.protocolId {
            return false
        }
        if lhs.priorityFlag != rhs.priorityFlag {
            return false
        }
        if lhs.scheduleDeliveryTime != rhs.scheduleDeliveryTime {
            return false
        }
        if lhs.validityPeriod != rhs.validityPeriod {
            return false
        }
        if lhs.registeredDelivery != rhs.registeredDelivery {
            return false
        }
        if lhs.replaceIfPresentFlag != rhs.replaceIfPresentFlag {
            return false
        }
        if lhs.dataCoding != rhs.dataCoding {
            return false
        }
        if lhs.smDefaultMsgId != rhs.smDefaultMsgId {
            return false
        }
        if lhs.shortMessage != rhs.shortMessage {
            return false
        }
        if lhs.tlvs != rhs.tlvs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(serviceType)
        hasher.combine(sourceAddrTon)
        hasher.combine(sourceAddrNpi)
        hasher.combine(sourceAddr)
        hasher.combine(destAddrTon)
        hasher.combine(destAddrNpi)
        hasher.combine(destinationAddr)
        hasher.combine(esmClass)
        hasher.combine(protocolId)
        hasher.combine(priorityFlag)
        hasher.combine(scheduleDeliveryTime)
        hasher.combine(validityPeriod)
        hasher.combine(registeredDelivery)
        hasher.combine(replaceIfPresentFlag)
        hasher.combine(dataCoding)
        hasher.combine(smDefaultMsgId)
        hasher.combine(shortMessage)
        hasher.combine(tlvs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubmitSmRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubmitSmRequest {
        return
            try SubmitSmRequest(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                serviceType: FfiConverterString.read(from: &buf), 
                sourceAddrTon: FfiConverterTypeTon.read(from: &buf), 
                sourceAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                sourceAddr: FfiConverterString.read(from: &buf), 
                destAddrTon: FfiConverterTypeTon.read(from: &buf), 
                destAddrNpi: FfiConverterTypeNpi.read(from: &buf), 
                destinationAddr: FfiConverterString.read(from: &buf), 
                esmClass: FfiConverterUInt8.read(from: &buf), 
                protocolId: FfiConverterUInt8.read(from: &buf), 
                priorityFlag: FfiConverterUInt8.read(from: &buf), 
                scheduleDeliveryTime: FfiConverterOptionString.read(from: &buf), 
                validityPeriod: FfiConverterOptionString.read(from: &buf), 
                registeredDelivery: FfiConverterUInt8.read(from: &buf), 
                replaceIfPresentFlag: FfiConverterUInt8.read(from: &buf), 
                dataCoding: FfiConverterUInt8.read(from: &buf), 
                smDefaultMsgId: FfiConverterUInt8.read(from: &buf), 
                shortMessage: FfiConverterData.read(from: &buf), 
                tlvs: FfiConverterSequenceTypeTlv.read(from: &buf)
        )
    }

    public static func write(_ value: SubmitSmRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterString.write(value.serviceType, into: &buf)
        FfiConverterTypeTon.write(value.sourceAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.sourceAddrNpi, into: &buf)
        FfiConverterString.write(value.sourceAddr, into: &buf)
        FfiConverterTypeTon.write(value.destAddrTon, into: &buf)
        FfiConverterTypeNpi.write(value.destAddrNpi, into: &buf)
        FfiConverterString.write(value.destinationAddr, into: &buf)
        FfiConverterUInt8.write(value.esmClass, into: &buf)
        FfiConverterUInt8.write(value.protocolId, into: &buf)
        FfiConverterUInt8.write(value.priorityFlag, into: &buf)
        FfiConverterOptionString.write(value.scheduleDeliveryTime, into: &buf)
        FfiConverterOptionString.write(value.validityPeriod, into: &buf)
        FfiConverterUInt8.write(value.registeredDelivery, into: &buf)
        FfiConverterUInt8.write(value.replaceIfPresentFlag, into: &buf)
        FfiConverterUInt8.write(value.dataCoding, into: &buf)
        FfiConverterUInt8.write(value.smDefaultMsgId, into: &buf)
        FfiConverterData.write(value.shortMessage, into: &buf)
        FfiConverterSequenceTypeTlv.write(value.tlvs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubmitSmRequest_lift(_ buf: RustBuffer) throws -> SubmitSmRequest {
    return try FfiConverterTypeSubmitSmRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubmitSmRequest_lower(_ value: SubmitSmRequest) -> RustBuffer {
    return FfiConverterTypeSubmitSmRequest.lower(value)
}


/**
 * Represents a Submit SM response.
 */
public struct SubmitSmResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32
    /**
     * The message ID.
     */
    public var messageId: String
    /**
     * The status description.
     */
    public var statusDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32, 
        /**
         * The message ID.
         */messageId: String, 
        /**
         * The status description.
         */statusDescription: String) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
        self.messageId = messageId
        self.statusDescription = statusDescription
    }
}



extension SubmitSmResponse: Equatable, Hashable {
    public static func ==(lhs: SubmitSmResponse, rhs: SubmitSmResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.statusDescription != rhs.statusDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
        hasher.combine(messageId)
        hasher.combine(statusDescription)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubmitSmResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubmitSmResponse {
        return
            try SubmitSmResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf), 
                messageId: FfiConverterString.read(from: &buf), 
                statusDescription: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SubmitSmResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterString.write(value.statusDescription, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubmitSmResponse_lift(_ buf: RustBuffer) throws -> SubmitSmResponse {
    return try FfiConverterTypeSubmitSmResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubmitSmResponse_lower(_ value: SubmitSmResponse) -> RustBuffer {
    return FfiConverterTypeSubmitSmResponse.lower(value)
}


/**
 * Tag-Length-Value (TLV) Parameter
 */
public struct Tlv {
    /**
     * The tag identifier for the parameter
     */
    public var tag: UInt16
    /**
     * The length of the value field
     */
    public var length: UInt16
    /**
     * The value of the parameter
     */
    public var value: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The tag identifier for the parameter
         */tag: UInt16, 
        /**
         * The length of the value field
         */length: UInt16, 
        /**
         * The value of the parameter
         */value: Data) {
        self.tag = tag
        self.length = length
        self.value = value
    }
}



extension Tlv: Equatable, Hashable {
    public static func ==(lhs: Tlv, rhs: Tlv) -> Bool {
        if lhs.tag != rhs.tag {
            return false
        }
        if lhs.length != rhs.length {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tag)
        hasher.combine(length)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTlv: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tlv {
        return
            try Tlv(
                tag: FfiConverterUInt16.read(from: &buf), 
                length: FfiConverterUInt16.read(from: &buf), 
                value: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Tlv, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.tag, into: &buf)
        FfiConverterUInt16.write(value.length, into: &buf)
        FfiConverterData.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTlv_lift(_ buf: RustBuffer) throws -> Tlv {
    return try FfiConverterTypeTlv.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTlv_lower(_ value: Tlv) -> RustBuffer {
    return FfiConverterTypeTlv.lower(value)
}


/**
 * Represents an Unbind request.
 */
public struct Unbind {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32) {
        self.sequenceNumber = sequenceNumber
    }
}



extension Unbind: Equatable, Hashable {
    public static func ==(lhs: Unbind, rhs: Unbind) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnbind: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unbind {
        return
            try Unbind(
                sequenceNumber: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Unbind, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnbind_lift(_ buf: RustBuffer) throws -> Unbind {
    return try FfiConverterTypeUnbind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnbind_lower(_ value: Unbind) -> RustBuffer {
    return FfiConverterTypeUnbind.lower(value)
}


/**
 * Represents an Unbind response.
 */
public struct UnbindResponse {
    /**
     * The sequence number of the PDU.
     */
    public var sequenceNumber: UInt32
    /**
     * The command status.
     */
    public var commandStatus: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The sequence number of the PDU.
         */sequenceNumber: UInt32, 
        /**
         * The command status.
         */commandStatus: UInt32) {
        self.sequenceNumber = sequenceNumber
        self.commandStatus = commandStatus
    }
}



extension UnbindResponse: Equatable, Hashable {
    public static func ==(lhs: UnbindResponse, rhs: UnbindResponse) -> Bool {
        if lhs.sequenceNumber != rhs.sequenceNumber {
            return false
        }
        if lhs.commandStatus != rhs.commandStatus {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sequenceNumber)
        hasher.combine(commandStatus)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnbindResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnbindResponse {
        return
            try UnbindResponse(
                sequenceNumber: FfiConverterUInt32.read(from: &buf), 
                commandStatus: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: UnbindResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.sequenceNumber, into: &buf)
        FfiConverterUInt32.write(value.commandStatus, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnbindResponse_lift(_ buf: RustBuffer) throws -> UnbindResponse {
    return try FfiConverterTypeUnbindResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnbindResponse_lower(_ value: UnbindResponse) -> RustBuffer {
    return FfiConverterTypeUnbindResponse.lower(value)
}


/**
 * Represents an unsuccessful delivery attempt in Submit Multi response.
 */
public struct UnsuccessfulDelivery {
    /**
     * Type of Number for the address.
     */
    public var ton: Ton
    /**
     * Numbering Plan Indicator for the address.
     */
    public var npi: Npi
    /**
     * The address that failed.
     */
    public var address: String
    /**
     * The error status code.
     */
    public var errorStatus: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Type of Number for the address.
         */ton: Ton, 
        /**
         * Numbering Plan Indicator for the address.
         */npi: Npi, 
        /**
         * The address that failed.
         */address: String, 
        /**
         * The error status code.
         */errorStatus: UInt32) {
        self.ton = ton
        self.npi = npi
        self.address = address
        self.errorStatus = errorStatus
    }
}



extension UnsuccessfulDelivery: Equatable, Hashable {
    public static func ==(lhs: UnsuccessfulDelivery, rhs: UnsuccessfulDelivery) -> Bool {
        if lhs.ton != rhs.ton {
            return false
        }
        if lhs.npi != rhs.npi {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.errorStatus != rhs.errorStatus {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ton)
        hasher.combine(npi)
        hasher.combine(address)
        hasher.combine(errorStatus)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsuccessfulDelivery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsuccessfulDelivery {
        return
            try UnsuccessfulDelivery(
                ton: FfiConverterTypeTon.read(from: &buf), 
                npi: FfiConverterTypeNpi.read(from: &buf), 
                address: FfiConverterString.read(from: &buf), 
                errorStatus: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: UnsuccessfulDelivery, into buf: inout [UInt8]) {
        FfiConverterTypeTon.write(value.ton, into: &buf)
        FfiConverterTypeNpi.write(value.npi, into: &buf)
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterUInt32.write(value.errorStatus, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsuccessfulDelivery_lift(_ buf: RustBuffer) throws -> UnsuccessfulDelivery {
    return try FfiConverterTypeUnsuccessfulDelivery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsuccessfulDelivery_lower(_ value: UnsuccessfulDelivery) -> RustBuffer {
    return FfiConverterTypeUnsuccessfulDelivery.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Bind Mode (Receiver, Transmitter, Transceiver)
 */

public enum BindMode {
    
    /**
     * Receiver Mode
     */
    case receiver
    /**
     * Transmitter Mode
     */
    case transmitter
    /**
     * Transceiver Mode
     */
    case transceiver
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBindMode: FfiConverterRustBuffer {
    typealias SwiftType = BindMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BindMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .receiver
        
        case 2: return .transmitter
        
        case 3: return .transceiver
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BindMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .receiver:
            writeInt(&buf, Int32(1))
        
        
        case .transmitter:
            writeInt(&buf, Int32(2))
        
        
        case .transceiver:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBindMode_lift(_ buf: RustBuffer) throws -> BindMode {
    return try FfiConverterTypeBindMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBindMode_lower(_ value: BindMode) -> RustBuffer {
    return FfiConverterTypeBindMode.lower(value)
}



extension BindMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents a destination for Submit Multi.
 */

public enum Destination {
    
    /**
     * SME Address
     */
    case smeAddress(
        /**
         * Type of Number.
         */ton: Ton, 
        /**
         * Numbering Plan Indicator.
         */npi: Npi, 
        /**
         * The address.
         */address: String
    )
    /**
     * Distribution List
     */
    case distributionList(
        /**
         * The name of the distribution list.
         */name: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDestination: FfiConverterRustBuffer {
    typealias SwiftType = Destination

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Destination {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .smeAddress(ton: try FfiConverterTypeTon.read(from: &buf), npi: try FfiConverterTypeNpi.read(from: &buf), address: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .distributionList(name: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Destination, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .smeAddress(ton,npi,address):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTon.write(ton, into: &buf)
            FfiConverterTypeNpi.write(npi, into: &buf)
            FfiConverterString.write(address, into: &buf)
            
        
        case let .distributionList(name):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(name, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDestination_lift(_ buf: RustBuffer) throws -> Destination {
    return try FfiConverterTypeDestination.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDestination_lower(_ value: Destination) -> RustBuffer {
    return FfiConverterTypeDestination.lower(value)
}



extension Destination: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Encoding type for message splitting.
 */

public enum EncodingType {
    
    /**
     * GSM 7-bit encoding.
     */
    case gsm7Bit
    /**
     * Latin-1 encoding.
     */
    case latin1
    /**
     * UCS-2 (UTF-16) encoding.
     */
    case ucs2
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEncodingType: FfiConverterRustBuffer {
    typealias SwiftType = EncodingType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncodingType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .gsm7Bit
        
        case 2: return .latin1
        
        case 3: return .ucs2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncodingType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .gsm7Bit:
            writeInt(&buf, Int32(1))
        
        
        case .latin1:
            writeInt(&buf, Int32(2))
        
        
        case .ucs2:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncodingType_lift(_ buf: RustBuffer) throws -> EncodingType {
    return try FfiConverterTypeEncodingType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncodingType_lower(_ value: EncodingType) -> RustBuffer {
    return FfiConverterTypeEncodingType.lower(value)
}



extension EncodingType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the state of a message.
 */

public enum MessageState {
    
    /**
     * Message is in enroute state
     */
    case enroute
    /**
     * Message is delivered
     */
    case delivered
    /**
     * Message validity period has expired
     */
    case expired
    /**
     * Message has been deleted
     */
    case deleted
    /**
     * Message is undeliverable
     */
    case undeliverable
    /**
     * Message is in accepted state
     */
    case accepted
    /**
     * Message is in invalid state
     */
    case unknown
    /**
     * Message is in rejected state
     */
    case rejected
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageState: FfiConverterRustBuffer {
    typealias SwiftType = MessageState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .enroute
        
        case 2: return .delivered
        
        case 3: return .expired
        
        case 4: return .deleted
        
        case 5: return .undeliverable
        
        case 6: return .accepted
        
        case 7: return .unknown
        
        case 8: return .rejected
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .enroute:
            writeInt(&buf, Int32(1))
        
        
        case .delivered:
            writeInt(&buf, Int32(2))
        
        
        case .expired:
            writeInt(&buf, Int32(3))
        
        
        case .deleted:
            writeInt(&buf, Int32(4))
        
        
        case .undeliverable:
            writeInt(&buf, Int32(5))
        
        
        case .accepted:
            writeInt(&buf, Int32(6))
        
        
        case .unknown:
            writeInt(&buf, Int32(7))
        
        
        case .rejected:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageState_lift(_ buf: RustBuffer) throws -> MessageState {
    return try FfiConverterTypeMessageState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageState_lower(_ value: MessageState) -> RustBuffer {
    return FfiConverterTypeMessageState.lower(value)
}



extension MessageState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Address Numbering Plan Indicator (NPI)
 */

public enum Npi {
    
    /**
     * Unknown
     */
    case unknown
    /**
     * ISDN
     */
    case isdn
    /**
     * Data
     */
    case data
    /**
     * Telex
     */
    case telex
    /**
     * Land Mobile
     */
    case landMobile
    /**
     * National
     */
    case national
    /**
     * Private
     */
    case `private`
    /**
     * ERMES
     */
    case ermes
    /**
     * Internet
     */
    case internet
    /**
     * WAP
     */
    case wap
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNpi: FfiConverterRustBuffer {
    typealias SwiftType = Npi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Npi {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .isdn
        
        case 3: return .data
        
        case 4: return .telex
        
        case 5: return .landMobile
        
        case 6: return .national
        
        case 7: return .`private`
        
        case 8: return .ermes
        
        case 9: return .internet
        
        case 10: return .wap
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Npi, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .isdn:
            writeInt(&buf, Int32(2))
        
        
        case .data:
            writeInt(&buf, Int32(3))
        
        
        case .telex:
            writeInt(&buf, Int32(4))
        
        
        case .landMobile:
            writeInt(&buf, Int32(5))
        
        
        case .national:
            writeInt(&buf, Int32(6))
        
        
        case .`private`:
            writeInt(&buf, Int32(7))
        
        
        case .ermes:
            writeInt(&buf, Int32(8))
        
        
        case .internet:
            writeInt(&buf, Int32(9))
        
        
        case .wap:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNpi_lift(_ buf: RustBuffer) throws -> Npi {
    return try FfiConverterTypeNpi.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNpi_lower(_ value: Npi) -> RustBuffer {
    return FfiConverterTypeNpi.lower(value)
}



extension Npi: Equatable, Hashable {}




/**
 * Common error type for FFI operations.
 */
public enum SmppFfiError {

    
    
    /**
     * Generic error with a message.
     */
    case Generic(
        /**
         * The error message.
         */msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSmppFfiError: FfiConverterRustBuffer {
    typealias SwiftType = SmppFfiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SmppFfiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SmppFfiError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension SmppFfiError: Equatable, Hashable {}

extension SmppFfiError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Message splitting mode.
 */

public enum SplitMode {
    
    /**
     * Use User Data Header (UDH) for concatenation.
     */
    case udh
    /**
     * Use SAR (Segmentation and Reassembly) TLVs.
     */
    case sar
    /**
     * Put everything in payload (no splitting, just payload).
     */
    case payload
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSplitMode: FfiConverterRustBuffer {
    typealias SwiftType = SplitMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SplitMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .udh
        
        case 2: return .sar
        
        case 3: return .payload
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SplitMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .udh:
            writeInt(&buf, Int32(1))
        
        
        case .sar:
            writeInt(&buf, Int32(2))
        
        
        case .payload:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSplitMode_lift(_ buf: RustBuffer) throws -> SplitMode {
    return try FfiConverterTypeSplitMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSplitMode_lower(_ value: SplitMode) -> RustBuffer {
    return FfiConverterTypeSplitMode.lower(value)
}



extension SplitMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Address Type of Number (TON)
 */

public enum Ton {
    
    /**
     * Unknown
     */
    case unknown
    /**
     * International
     */
    case international
    /**
     * National
     */
    case national
    /**
     * Network Specific
     */
    case networkSpecific
    /**
     * Subscriber Number
     */
    case subscriberNumber
    /**
     * Alphanumeric
     */
    case alphanumeric
    /**
     * Abbreviated
     */
    case abbreviated
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTon: FfiConverterRustBuffer {
    typealias SwiftType = Ton

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ton {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .international
        
        case 3: return .national
        
        case 4: return .networkSpecific
        
        case 5: return .subscriberNumber
        
        case 6: return .alphanumeric
        
        case 7: return .abbreviated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Ton, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .international:
            writeInt(&buf, Int32(2))
        
        
        case .national:
            writeInt(&buf, Int32(3))
        
        
        case .networkSpecific:
            writeInt(&buf, Int32(4))
        
        
        case .subscriberNumber:
            writeInt(&buf, Int32(5))
        
        
        case .alphanumeric:
            writeInt(&buf, Int32(6))
        
        
        case .abbreviated:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTon_lift(_ buf: RustBuffer) throws -> Ton {
    return try FfiConverterTypeTon.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTon_lower(_ value: Ton) -> RustBuffer {
    return FfiConverterTypeTon.lower(value)
}



extension Ton: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTlv: FfiConverterRustBuffer {
    typealias SwiftType = [Tlv]

    public static func write(_ value: [Tlv], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTlv.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Tlv] {
        let len: Int32 = try readInt(&buf)
        var seq = [Tlv]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTlv.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUnsuccessfulDelivery: FfiConverterRustBuffer {
    typealias SwiftType = [UnsuccessfulDelivery]

    public static func write(_ value: [UnsuccessfulDelivery], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnsuccessfulDelivery.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnsuccessfulDelivery] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnsuccessfulDelivery]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnsuccessfulDelivery.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDestination: FfiConverterRustBuffer {
    typealias SwiftType = [Destination]

    public static func write(_ value: [Destination], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDestination.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Destination] {
        let len: Int32 = try readInt(&buf)
        var seq = [Destination]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDestination.read(from: &buf))
        }
        return seq
    }
}
/**
 * Decodes a byte buffer into a `BindRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeBindRequest(buffer: Data)throws  -> BindRequest {
    return try  FfiConverterTypeBindRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_bind_request(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `BindResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeBindResponse(buffer: Data)throws  -> BindResponse {
    return try  FfiConverterTypeBindResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_bind_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `BroadcastSmRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeBroadcastSmRequest(buffer: Data)throws  -> BroadcastSmRequest {
    return try  FfiConverterTypeBroadcastSmRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_broadcast_sm_request(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `BroadcastSmResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeBroadcastSmResponse(buffer: Data)throws  -> BroadcastSmResponse {
    return try  FfiConverterTypeBroadcastSmResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_broadcast_sm_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `CancelBroadcastSmRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeCancelBroadcastSmRequest(buffer: Data)throws  -> CancelBroadcastSmRequest {
    return try  FfiConverterTypeCancelBroadcastSmRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_cancel_broadcast_sm_request(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `CancelBroadcastSmResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeCancelBroadcastSmResponse(buffer: Data)throws  -> CancelBroadcastSmResponse {
    return try  FfiConverterTypeCancelBroadcastSmResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_cancel_broadcast_sm_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `CancelSmRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeCancelSmRequest(buffer: Data)throws  -> CancelSmRequest {
    return try  FfiConverterTypeCancelSmRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_cancel_sm_request(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `CancelSmResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeCancelSmResponse(buffer: Data)throws  -> CancelSmResponse {
    return try  FfiConverterTypeCancelSmResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_cancel_sm_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `DataSm` request.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeDataSm(buffer: Data)throws  -> DataSm {
    return try  FfiConverterTypeDataSm.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_data_sm(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `DataSmResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeDataSmResponse(buffer: Data)throws  -> DataSmResponse {
    return try  FfiConverterTypeDataSmResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_data_sm_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `DeliverSmRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeDeliverSm(buffer: Data)throws  -> DeliverSmRequest {
    return try  FfiConverterTypeDeliverSmRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_deliver_sm(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `DeliverSmResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeDeliverySmResponse(buffer: Data)throws  -> DeliverSmResponse {
    return try  FfiConverterTypeDeliverSmResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_delivery_sm_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into an `EnquireLink` request.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeEnquireLink(buffer: Data)throws  -> EnquireLink {
    return try  FfiConverterTypeEnquireLink.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_enquire_link(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into an `EnquireLinkResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeEnquireLinkResponse(buffer: Data)throws  -> EnquireLinkResponse {
    return try  FfiConverterTypeEnquireLinkResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_enquire_link_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `GenericNack`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeGenericNack(buffer: Data)throws  -> GenericNack {
    return try  FfiConverterTypeGenericNack.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_generic_nack(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into an `Outbind` request.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeOutbind(buffer: Data)throws  -> Outbind {
    return try  FfiConverterTypeOutbind.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_outbind(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `QueryBroadcastSmRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeQueryBroadcastSmRequest(buffer: Data)throws  -> QueryBroadcastSmRequest {
    return try  FfiConverterTypeQueryBroadcastSmRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_query_broadcast_sm_request(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `QueryBroadcastSmResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeQueryBroadcastSmResponse(buffer: Data)throws  -> QueryBroadcastSmResponse {
    return try  FfiConverterTypeQueryBroadcastSmResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_query_broadcast_sm_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `QuerySmRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeQuerySmRequest(buffer: Data)throws  -> QuerySmRequest {
    return try  FfiConverterTypeQuerySmRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_query_sm_request(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `QuerySmResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeQuerySmResponse(buffer: Data)throws  -> QuerySmResponse {
    return try  FfiConverterTypeQuerySmResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_query_sm_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `ReplaceSmRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeReplaceSmRequest(buffer: Data)throws  -> ReplaceSmRequest {
    return try  FfiConverterTypeReplaceSmRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_replace_sm_request(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `ReplaceSmResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeReplaceSmResponse(buffer: Data)throws  -> ReplaceSmResponse {
    return try  FfiConverterTypeReplaceSmResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_replace_sm_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `SubmitMultiRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeSubmitMultiRequest(buffer: Data)throws  -> SubmitMultiRequest {
    return try  FfiConverterTypeSubmitMultiRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_submit_multi_request(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `SubmitMultiResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeSubmitMultiResponse(buffer: Data)throws  -> SubmitMultiResponse {
    return try  FfiConverterTypeSubmitMultiResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_submit_multi_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `SubmitSmRequest`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeSubmitSmRequest(buffer: Data)throws  -> SubmitSmRequest {
    return try  FfiConverterTypeSubmitSmRequest.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_submit_sm_request(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into a `SubmitSmResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeSubmitSmResponse(buffer: Data)throws  -> SubmitSmResponse {
    return try  FfiConverterTypeSubmitSmResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_submit_sm_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into an `Unbind` request.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeUnbind(buffer: Data)throws  -> Unbind {
    return try  FfiConverterTypeUnbind.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_unbind(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Decodes a byte buffer into an `UnbindResponse`.
 *
 * # Errors
 *
 * Returns an error string if the decoding fails.
 */
public func decodeUnbindResponse(buffer: Data)throws  -> UnbindResponse {
    return try  FfiConverterTypeUnbindResponse.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_decode_unbind_response(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Encodes a `BindRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeBindRequest(req: BindRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_bind_request(
        FfiConverterTypeBindRequest.lower(req),$0
    )
})
}
/**
 * Encodes a `BindResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeBindResponse(req: BindResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_bind_response(
        FfiConverterTypeBindResponse.lower(req),$0
    )
})
}
/**
 * Encodes a `BroadcastSmRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeBroadcastSmRequest(request: BroadcastSmRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_broadcast_sm_request(
        FfiConverterTypeBroadcastSmRequest.lower(request),$0
    )
})
}
/**
 * Encodes a `BroadcastSmResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeBroadcastSmResponse(response: BroadcastSmResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_broadcast_sm_response(
        FfiConverterTypeBroadcastSmResponse.lower(response),$0
    )
})
}
/**
 * Encodes a `CancelBroadcastSmRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeCancelBroadcastSmRequest(request: CancelBroadcastSmRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_cancel_broadcast_sm_request(
        FfiConverterTypeCancelBroadcastSmRequest.lower(request),$0
    )
})
}
/**
 * Encodes a `CancelBroadcastSmResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeCancelBroadcastSmResponse(response: CancelBroadcastSmResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_cancel_broadcast_sm_response(
        FfiConverterTypeCancelBroadcastSmResponse.lower(response),$0
    )
})
}
/**
 * Encodes a `CancelSmRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeCancelSmRequest(request: CancelSmRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_cancel_sm_request(
        FfiConverterTypeCancelSmRequest.lower(request),$0
    )
})
}
/**
 * Encodes a `CancelSmResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeCancelSmResponse(response: CancelSmResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_cancel_sm_response(
        FfiConverterTypeCancelSmResponse.lower(response),$0
    )
})
}
/**
 * Encodes a `DataSm` request into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeDataSm(request: DataSm) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_data_sm(
        FfiConverterTypeDataSm.lower(request),$0
    )
})
}
/**
 * Encodes a `DataSmResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeDataSmResponse(response: DataSmResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_data_sm_response(
        FfiConverterTypeDataSmResponse.lower(response),$0
    )
})
}
/**
 * Encodes a `DeliverSmRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeDeliverSm(request: DeliverSmRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_deliver_sm(
        FfiConverterTypeDeliverSmRequest.lower(request),$0
    )
})
}
/**
 * Encodes a `DeliveryReceipt` into a byte vector (string representation).
 */
public func encodeDeliveryReceipt(receipt: DeliveryReceipt) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_delivery_receipt(
        FfiConverterTypeDeliveryReceipt.lower(receipt),$0
    )
})
}
/**
 * Encodes a `DeliverSmResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeDeliverySmResponse(response: DeliverSmResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_delivery_sm_response(
        FfiConverterTypeDeliverSmResponse.lower(response),$0
    )
})
}
/**
 * Encodes an `EnquireLink` request into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeEnquireLink(req: EnquireLink) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_enquire_link(
        FfiConverterTypeEnquireLink.lower(req),$0
    )
})
}
/**
 * Encodes an `EnquireLinkResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeEnquireLinkResponse(req: EnquireLinkResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_enquire_link_response(
        FfiConverterTypeEnquireLinkResponse.lower(req),$0
    )
})
}
/**
 * Encodes a `GenericNack` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeGenericNack(req: GenericNack) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_generic_nack(
        FfiConverterTypeGenericNack.lower(req),$0
    )
})
}
/**
 * Encodes an `Outbind` request into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeOutbind(req: Outbind) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_outbind(
        FfiConverterTypeOutbind.lower(req),$0
    )
})
}
/**
 * Encodes a `QueryBroadcastSmRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeQueryBroadcastSmRequest(request: QueryBroadcastSmRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_query_broadcast_sm_request(
        FfiConverterTypeQueryBroadcastSmRequest.lower(request),$0
    )
})
}
/**
 * Encodes a `QueryBroadcastSmResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeQueryBroadcastSmResponse(response: QueryBroadcastSmResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_query_broadcast_sm_response(
        FfiConverterTypeQueryBroadcastSmResponse.lower(response),$0
    )
})
}
/**
 * Encodes a `QuerySmRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeQuerySmRequest(request: QuerySmRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_query_sm_request(
        FfiConverterTypeQuerySmRequest.lower(request),$0
    )
})
}
/**
 * Encodes a `QuerySmResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeQuerySmResponse(response: QuerySmResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_query_sm_response(
        FfiConverterTypeQuerySmResponse.lower(response),$0
    )
})
}
/**
 * Encodes a `ReplaceSmRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeReplaceSmRequest(request: ReplaceSmRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_replace_sm_request(
        FfiConverterTypeReplaceSmRequest.lower(request),$0
    )
})
}
/**
 * Encodes a `ReplaceSmResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeReplaceSmResponse(response: ReplaceSmResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_replace_sm_response(
        FfiConverterTypeReplaceSmResponse.lower(response),$0
    )
})
}
/**
 * Encodes a `SubmitMultiRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeSubmitMultiRequest(request: SubmitMultiRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_submit_multi_request(
        FfiConverterTypeSubmitMultiRequest.lower(request),$0
    )
})
}
/**
 * Encodes a `SubmitMultiResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeSubmitMultiResponse(response: SubmitMultiResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_submit_multi_response(
        FfiConverterTypeSubmitMultiResponse.lower(response),$0
    )
})
}
/**
 * Encodes a `SubmitSmRequest` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails (which should not happen for valid input).
 */
public func encodeSubmitSmRequest(request: SubmitSmRequest) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_submit_sm_request(
        FfiConverterTypeSubmitSmRequest.lower(request),$0
    )
})
}
/**
 * Encodes a `SubmitSmResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeSubmitSmResponse(response: SubmitSmResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_submit_sm_response(
        FfiConverterTypeSubmitSmResponse.lower(response),$0
    )
})
}
/**
 * Encodes an `Unbind` request into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeUnbind(req: Unbind) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_unbind(
        FfiConverterTypeUnbind.lower(req),$0
    )
})
}
/**
 * Encodes an `UnbindResponse` into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func encodeUnbindResponse(req: UnbindResponse) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_encode_unbind_response(
        FfiConverterTypeUnbindResponse.lower(req),$0
    )
})
}
/**
 * Splits a message into multiple parts based on the specified encoding and mode.
 *
 * # Errors
 *
 * Returns an error string if the splitting fails.
 */
public func splitMessage(text: String, encoding: EncodingType, mode: SplitMode)throws  -> SplitResult {
    return try  FfiConverterTypeSplitResult.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_split_message(
        FfiConverterString.lower(text),
        FfiConverterTypeEncodingType.lower(encoding),
        FfiConverterTypeSplitMode.lower(mode),$0
    )
})
}
/**
 * Decodes a byte buffer into a TLV.
 *
 * # Errors
 *
 * Returns an error if the decoding fails.
 */
public func tlvDecode(buffer: Data)throws  -> Tlv {
    return try  FfiConverterTypeTlv.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_tlv_decode(
        FfiConverterData.lower(buffer),$0
    )
})
}
/**
 * Encodes a TLV into a byte vector.
 *
 * # Panics
 *
 * Panics if the internal encoding fails.
 */
public func tlvEncode(tlv: Tlv) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_tlv_encode(
        FfiConverterTypeTlv.lower(tlv),$0
    )
})
}
/**
 * Creates a new TLV with the given tag and value.
 */
public func tlvNew(tag: UInt16, value: Data) -> Tlv {
    return try!  FfiConverterTypeTlv.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_tlv_new(
        FfiConverterUInt16.lower(tag),
        FfiConverterData.lower(value),$0
    )
})
}
/**
 * Creates a new TLV with a tag name and value.
 */
public func tlvNewFromName(name: String, value: Data) -> Tlv {
    return try!  FfiConverterTypeTlv.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_tlv_new_from_name(
        FfiConverterString.lower(name),
        FfiConverterData.lower(value),$0
    )
})
}
/**
 * Creates a new TLV with a message payload.
 */
public func tlvNewPayload(tag: UInt16, value: Data) -> Tlv {
    return try!  FfiConverterTypeTlv.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_tlv_new_payload(
        FfiConverterUInt16.lower(tag),
        FfiConverterData.lower(value),$0
    )
})
}
/**
 * Creates a new TLV with a string value.
 */
public func tlvNewString(tag: UInt16, value: String) -> Tlv {
    return try!  FfiConverterTypeTlv.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_tlv_new_string(
        FfiConverterUInt16.lower(tag),
        FfiConverterString.lower(value),$0
    )
})
}
/**
 * Creates a new TLV with a u16 value.
 */
public func tlvNewU16(tag: UInt16, value: UInt16) -> Tlv {
    return try!  FfiConverterTypeTlv.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_tlv_new_u16(
        FfiConverterUInt16.lower(tag),
        FfiConverterUInt16.lower(value),$0
    )
})
}
/**
 * Creates a new TLV with a tag name and u16 value.
 */
public func tlvNewU16FromName(name: String, value: UInt16) -> Tlv {
    return try!  FfiConverterTypeTlv.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_tlv_new_u16_from_name(
        FfiConverterString.lower(name),
        FfiConverterUInt16.lower(value),$0
    )
})
}
/**
 * Creates a new TLV with a u8 value.
 */
public func tlvNewU8(tag: UInt16, value: UInt8) -> Tlv {
    return try!  FfiConverterTypeTlv.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_tlv_new_u8(
        FfiConverterUInt16.lower(tag),
        FfiConverterUInt8.lower(value),$0
    )
})
}
/**
 * Creates a new TLV with a tag name and u8 value.
 */
public func tlvNewU8FromName(name: String, value: UInt8) -> Tlv {
    return try!  FfiConverterTypeTlv.lift(try! rustCall() {
    uniffi_smpp_codec_ffi_fn_func_tlv_new_u8_from_name(
        FfiConverterString.lower(name),
        FfiConverterUInt8.lower(value),$0
    )
})
}
/**
 * Extracts the value of the TLV as a String.
 *
 * # Errors
 *
 * Returns an error if the conversion fails.
 */
public func tlvValueAsString(tlv: Tlv)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_tlv_value_as_string(
        FfiConverterTypeTlv.lower(tlv),$0
    )
})
}
/**
 * Extracts the value of the TLV as a u16.
 *
 * # Errors
 *
 * Returns an error if the conversion fails.
 */
public func tlvValueAsU16(tlv: Tlv)throws  -> UInt16 {
    return try  FfiConverterUInt16.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_tlv_value_as_u16(
        FfiConverterTypeTlv.lower(tlv),$0
    )
})
}
/**
 * Extracts the value of the TLV as a u8.
 *
 * # Errors
 *
 * Returns an error if the conversion fails.
 */
public func tlvValueAsU8(tlv: Tlv)throws  -> UInt8 {
    return try  FfiConverterUInt8.lift(try rustCallWithError(FfiConverterTypeSmppFfiError.lift) {
    uniffi_smpp_codec_ffi_fn_func_tlv_value_as_u8(
        FfiConverterTypeTlv.lower(tlv),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_smpp_codec_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_bind_request() != 37333) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_bind_response() != 52036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_broadcast_sm_request() != 64554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_broadcast_sm_response() != 30285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_cancel_broadcast_sm_request() != 19193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_cancel_broadcast_sm_response() != 932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_cancel_sm_request() != 8859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_cancel_sm_response() != 51372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_data_sm() != 65231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_data_sm_response() != 19729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_deliver_sm() != 22285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_delivery_sm_response() != 33409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_enquire_link() != 16382) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_enquire_link_response() != 37015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_generic_nack() != 27336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_outbind() != 52924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_query_broadcast_sm_request() != 57506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_query_broadcast_sm_response() != 58148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_query_sm_request() != 18654) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_query_sm_response() != 39231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_replace_sm_request() != 28646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_replace_sm_response() != 48083) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_submit_multi_request() != 75) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_submit_multi_response() != 21200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_submit_sm_request() != 34053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_submit_sm_response() != 44481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_unbind() != 42864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_decode_unbind_response() != 5411) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_bind_request() != 58165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_bind_response() != 15393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_broadcast_sm_request() != 49275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_broadcast_sm_response() != 13146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_cancel_broadcast_sm_request() != 5810) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_cancel_broadcast_sm_response() != 13308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_cancel_sm_request() != 13790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_cancel_sm_response() != 15929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_data_sm() != 62637) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_data_sm_response() != 61010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_deliver_sm() != 8604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_delivery_receipt() != 38375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_delivery_sm_response() != 45073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_enquire_link() != 32915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_enquire_link_response() != 26910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_generic_nack() != 54901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_outbind() != 29048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_query_broadcast_sm_request() != 19166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_query_broadcast_sm_response() != 19591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_query_sm_request() != 44612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_query_sm_response() != 37328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_replace_sm_request() != 8829) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_replace_sm_response() != 26564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_submit_multi_request() != 40293) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_submit_multi_response() != 46081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_submit_sm_request() != 50559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_submit_sm_response() != 13726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_unbind() != 43768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_encode_unbind_response() != 63525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_split_message() != 14998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_decode() != 50274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_encode() != 41064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_new() != 19404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_new_from_name() != 1592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_new_payload() != 12958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_new_string() != 11341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_new_u16() != 36617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_new_u16_from_name() != 35465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_new_u8() != 53289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_new_u8_from_name() != 50680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_value_as_string() != 22623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_value_as_u16() != 2037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smpp_codec_ffi_checksum_func_tlv_value_as_u8() != 26695) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all